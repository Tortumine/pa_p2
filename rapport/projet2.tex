\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{amsmath} 
\usepackage{float}
%\usepackage[french,onelanguage,ruled,vlined]{algorithm2e}
%\usepackage{clrscode3e}
%\usepackage{algorithm, algpseudocode}
%\usepackage{tabular}
\usepackage[utf8]{inputenc}
\usepackage{clrscode3e}
%\usepackage{algpseudocode}

% changement de la numerotation
\setcounter{secnumdepth}{5}
%\renewcommand{\thechapter}{\Alph{chapter}}
%\renewcommand{\thesection}{\Roman{section})}
%\renewcommand{\thesubsection}{\arabic{subsection})}


%\title{\textbf{INFO2050 : Rapport numéro un programmation avancée}}
%\author{Antoine Sadzot}
%\date{30-10-17}
\begin{document}
\begin{titlepage}

   \begin{figure}[htbp]
      \centering
      \includegraphics{uliege-logo-couleurs-300.jpg}
   \end{figure}
  	
  	\hfill

	\begin{center}
		\vfill
		\textbf{
		\Huge{INFOXXXX - Cours}}\\
		\bigskip
		\huge{Titre}\\
		\bigskip %saut de ligne
		\smallskip
		\Large{Collaborateur0\\Collaborateur1\\Collaborateur2} \\
		\bigskip
		\smallskip
		\large{\today}\\%date
		\vfill
		\large{Université de Liège}
	\end{center}
\end{titlepage}
\clearpage
\clearpage

\section{Analyse Théorique}
\subsection{Variante d'union-find à base d'arbres choisie}
	La version de l'union-find en arbre implémentée est une amélioration poussée de la version en arbre classique. Comme dans la version de base chaque élément pointe vers son parent.
	Lors d'une union de sous-ensembles, les racines des deux arbres sont fusionnés, un parent se retrouve donc avec deux enfants.
	
	\paragraph{Rang}			
	La première amélioration consiste à associer un rang a chaque élément. Cela permet d'optimiser la fusion. L'union-find de base pouvait être fort déséquilibré, ce qui rendais l'appel Find() assez long. L'ajout d'un rang permet d'équilibrer l'arbre lors de l'union. 
	
	Au début tous les éléments ont un rang 0. Lors d'une fusion de deux arbres de même hauteur, le rang de la nouvelle racine est incrémenté de 1. Si les rangs sont différents, l'arbre ayant le rang le plus petit est ajouté à la racine de l'arbre le plus grand. Cela permet d'équilibrer la structure au fur et à mesure de la construction et ainsi de diminuer la hauteur maximale.
	
	\paragraph{Compression de chemin}
	Cette seconde amélioration consiste à utiliser la fonction Find() pour aplatir l'arbre. Cela ce fait lors de l'appel récursif, la racine de l'arbre remonte dans la call-stack et est définie en tant que parent de chaque neud parcouru. De cette manière, tous les éléments parcouru par un Find(), pointeront directement vers la racine et nécessiteront donc un temps constant pour récupérer cette dernière.

\subsection{Complexités en temps de ufUnion et ufFind}

\subsubsection{Implémentation à base de listes chainées}

\begin{description}
\item[ufFind :] Dans tous les cas, la complexité est theta(1)
\item[ufUnion :] Dans le meilleur cas, le plus petit ensemble à lier à la suite du second ensemble ne contient qu'un élément. La complexité dans le meilleur cas est donc theta(1). Dans le pire cas, l'ensemble à lier à la suite du second ensemble est de taille N/2, N étant le nombre d'éléments du labyrinthe. La complexité dans le pire cas est donc theta(N/2).
\end{description}
\subsubsection{Implémentation à base d'arbres}


\subsection{Implémentation de la structure du labyrinthe}
Les données du labyrinthe sont stockées dans la structure Maze. \\
struct maze\_t \{ \\
\quad    UnionFind *union\_Find; \\
\quad     struct Walls *myWalls; \\
\quad     size\_t size; \\
\quad     size\_t number\_inner\_walls; \\
\};\\

La structure "maze\_t" contient la structure "UnionFind", qui sera décrite pour chaque implémentation par la suite. Elle contient également la structure "Walls" qui est un vecteur enregistrant tous les murs internes du labyrinthe. La variable "size" contient la taille du labyrinthe. La variable "number\_inner\_walls" contient le nombre de mur internes du labyrinthe. C'est également la taille du vecteur de type "Walls". \\
\linebreak
typedef struct Walls \{ \\
    Coord Cell1; \\
    Coord Cell2; \\
    bool wall\_between; \\
\};\\

La structure "Walls" contient les coordonnées de deux cellules adjacentes, partageant un mur. La variable booléenne "wall" vaut "true" si le mur est présent. Elle vaut "false" si le mur est absent.\\

\subsubsection{Implementation par listes chainées}
La structure union\_find\_t est décrite de cette manière : \\ \\
struct union\_find\_t \{ \\
    struct Element* elements; \\
    struct Sentinel* sentinels; \\
    size\_t numberComponents; \\
\}; \\ \\
Elle contient un vecteur "elements" contenant tous les élements du labyrinthe structurés en listes chainées. Elle contient également un vecteur "sentinels" contenant toutes les sentinelles pointant sur les premiers et derniers éléments de chaque liste chainée. La variable "numberComponents" contient le nombre d'ensembles distincts. \\ \\
typedef struct Element \{\\
    size\_t numero;\\
    struct Sentinel* head;\\
    struct Element* next;\\
\}Element;\\ \\
Le "numero" correspond à l'indice de l'élément dans le labyrinthe. Le pointeur "head" pointe vers la sentinelle de l'ensemble auquel appartient l'élément. Le pointeur "next" pointe vers l'élement suivant dans la liste chainée.\\
\\
typedef struct Sentinel \{ \\
    struct Element* first; \\
    struct Element* last; \\
    size\_t numberElements; \\
\}Sentinel;\\ \\
Le pointeur "first" pointe vers le premier élément de la liste chainée liée à la sentinelle. Le pointeur "last" pointe vers le dernier élément de cette liste. La variable "numberElements" contient le nombre d'éléments présents dans cette liste.
\subsubsection{Implementation par arbres}

 

\subsection{Pseudocode des fonctions mzCreate et MzIsValid}

\begin{codebox}
\Procname {$mzIsValid(maze)$}
\li    \If $\proc{ufComponentsCount}(maze->union\_Find) > 1$
\li    \Then \Return $false;$
\li    \Else 
\li 		\Return $true;$
\end{codebox}

\begin{codebox}
\Procname {$mzCreate(size)$}
	\li $innerWalls \gets \proc{NumberInnerWalls}(size)$
	\li $myMaze->size = size$
	\li $myMaze->union_find \gets \proc{ufCreate}(size * size)$
	\li $myMaze->number\_inner\_walls \gets innerWalls$
	\li $\proc{SetUpWalls}(myMaze->myWalls, size*size)$
	\li $\proc{ShuffleWalls}(myMaze->myWalls, myMaze->number\_inner\_walls)$	
	\li $wallsToTest \gets 0$	
	\li \While $!\proc{mzIsValid}(myMaze) \&\& wallsToTest < innerWalls$
	\li \Do $indexCell1 \gets \proc{IndexFromCoord}(myMaze->myWalls[wallsToTest].Cell1)$
	\li 	$indexCell2 \gets \proc{IndexFromCoord}(myMaze->myWalls[wallsToTest].Cell2)$
	\li 	$status \gets \proc{ufUnion}(myMaze->union\_Find, indexCell1, indexCell2)$
	\li 	\If $status == UF\_MERGED$
			\Then
	\li 		$close \gets \proc{mzIsWallClosed}(myMaze, myMaze->myWalls[wallsToTest].Cell1,$ \\$myMaze->myWalls[wallsToTest].Cell2)$
	\li 		$\proc{mzSetWall}(myMaze, myMaze->myWalls[wallsToTest].Cell1,$ \\ $ myMaze->myWalls[wallsToTest].Cell2, close)$
			\End
	\li $wallsToTest++$	
		\End
	\li \Return $myMaze$
\end{codebox}
\subsection{Analyse de la complexité en temps de mzCreate et mzIsValid}

\subsubsection{Implémentation à base de listes chainées}
\begin{description}
\item[mzIsValid :]La fonction ufComponentsCount s'écrit comme telle :
\begin{codebox}
\Procname{$ufComponentsCount(union_Find)$}
\li \Return $union_Find->numberComponents$
\end{codebox}
Dans tous les cas, sa complexité est theta(1).

\item[mzCreate :] Seules les parties de la fonction présentant une complexité égale ou supérieure à $N^{2}$ sont présentées. Les autres sont ignorées car négligeables. \textbf{Dans tous les cas.} La ligne 3 est theta($N^{2}$) car chaque cellule est visitée une à une. A la la ligne 5, ($N^{2}$) itérations sont nécessaires car toutes les cellules sont visitées. Donc theta($N^{2}$).
A la ligne 6, chaque mur intérieur est visité, ce qui fait 2$N^{2}$ - 2N opérations, donc theta($N^{2}$).
La boucle à la ligne 8 va varier en fonction du meilleur et du pire cas. \\
\textbf{Dans le meilleur cas}, chaque itération permet une connexion de cellules. Cela fait donc $N^{2}$-1 itérations nécessaires. Au sein de la boucle, toutes les instructions on une complexité linéaire. C'est également le cas pour la ligne 11 dans le meilleur des cas. Car à chaque connexion d'ensembles, seul un élément est connecté à la fois. Donc,\textbf{ dans le meilleur cas}, la complexité en temps est de l'ordre de Omega($N^{2}$).
\textbf{Dans le pire cas}, tous les éléments du vecteur myWalls sont visités. Cela fait donc 2$N^{2}$ - 2N  itérations. Il n'y aura cependant toujours que $N^{2}$-1 opérations de connexion de cellules. Donc seule la ligne 11 aura une complexité variable. L'analyse de la complexité du ufUnion va se faire pour les cas où N est une puissance de 2, par facilité. Le pire cas correspond à celui où les ensembles connectés sont toujours de taille égale. Au début, tous les ensembles seront de taille 1, puis de taille 2, 4, 8,... jusqu'à ce qu'il ne reste plus qu'un ensemble. En prenant le problème à l'envers, on part d'un ensemble de $N^{2}$ éléments à $N^{2}$ ensemble d'un éléments :
\begin{equation}
	T(1) = 0
	T(m^{2}) = \frac{N^{2}}{2} + T(\frac{m^{2}}{2} pour m = N
\end{equation}
Par Plug-and-Chug, on obtient la solution suivante :
\begin{equation}
	log_{2} (N^{2}) * \frac{N^{2}}{2}
\end{equation}
Le pire cas de la boucle qui démarre en ligne 8 influencera donc la complexité totale.
\textbf{Dans le pire cas}, la complexité est de l'ordre de Omega($log_{2}$ ($N^{2}$)*$N^{2}$)
On observe que la complexité en temps du pire et du meilleur cas sont très proches.
\end{description}


\subsubsection{Implémentation à base d'arbres}
La structure en C est la suivante:
	\begin{lstlisting}[style=CStyle]
struct union_find_t {
    size_t* items;
    size_t* parrents;
    size_t* rank;
    size_t n_items;
    size_t n_trees;
};
\end{lstlisting}

Cette structure est composée de 3 tableaux:
\begin{itemize}
\item \textbf{items[n] :} Indices dans la grille du labyrinthe (n).
\item \textbf{parents[n] :} Parent direct de l'item n.
\item \textbf{rank[n] :} Rang de l'item n
\end{itemize}
Deux autres variables sont définies dans la structure:
\begin{itemize}
\item \textbf{n\_items :} Nombre total d'éléments.
\item \textbf{n\_trees :} Nombre d'ensembles.
\end{itemize}
	\subsection{Complexités en temps de ufUnion et ufFind}
		\subsubsection{Tree}
		\paragraph{Find}
		theta(Q)=c=1		
		\paragraph{Union}
		theta(Q)=c=1
	\subsection{Implémentation de la structure du labyrinthe}
	\subsection{Pseudo-code des fonctions mzCreate et MzIsValid}
	\subsection{Analyse de la complexité en temps de MzCreate et MzIsValid}
		\subsubsection{Implémentation à base de listes chainées}
		\subsubsection{Implémentation à base d'arbres}
			\paragraph{Find}		
		Find d'un élément prends un temps proportionnel à la hauteur de l'arbre la première fois. Avec l'amélioration \textit{Compression de chemin} la hauteur de cet élément et de ces parents est ramenée à 1, ce qui garantit un temps constant pour chaque élément teta(n)=n.

\section{Analyse empirique}

A FAIRE
\end{document}