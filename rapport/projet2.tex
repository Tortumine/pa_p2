\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{amsmath} 
\usepackage{float}
%\usepackage[french,onelanguage,ruled,vlined]{algorithm2e}
%\usepackage{clrscode3e}
%\usepackage{algorithm, algpseudocode}
%\usepackage{tabular}
\usepackage[utf8]{inputenc}
\usepackage{clrscode3e}
%\usepackage{algpseudocode}

% changement de la numerotation
\setcounter{secnumdepth}{5}
%\renewcommand{\thechapter}{\Alph{chapter}}
%\renewcommand{\thesection}{\Roman{section})}
%\renewcommand{\thesubsection}{\arabic{subsection})}


%\title{\textbf{INFO2050 : Rapport numéro un programmation avancée}}
%\author{Antoine Sadzot}
%\date{30-10-17}
\begin{document}
\begin{titlepage}

   \begin{figure}[htbp]
      \centering
%      \includegraphics{logoULG.jpg}
   \end{figure}
  	
  	\hfill

	\begin{center}
		\vfill
		\textbf{
		\Huge{INFO2050 - Programmation avancée}}\\
		\bigskip
		\huge{Projet 2: Structures de données}\\
		\bigskip %saut de ligne
		\smallskip
		\Large{Antoine Sadzot - Aliaksei Mazurchyk} \\
		\bigskip
		\smallskip
		\large{18 Novembre 2017}\\%date
		\vfill
		\large{Université de Liège}
	\end{center}
\end{titlepage}
\clearpage
%\maketitle
%\tableofcontents
\clearpage

\section{Analyse Théorique}
\subsection{Description de la variante d'union-find à base d'arbres choisie}


\subsection{Complexités en temps de ufUnion et ufFind}

\subsubsection{Implémentation à base de listes chainées}

\begin{description}
\item[ufFind :] Dans tous les cas, la complexité est theta(1)
\item[ufUnion :] Dans le meilleur cas, le plus petit ensemble à lier à la suite du second ensemble ne contient qu'un élément. La complexité dans le meilleur cas est donc theta(1). Dans le pire cas, l'ensemble à lier à la suite du second ensemble est de taille N/2, N étant le nombre d'éléments du labyrinthe. La complexité dans le pire cas est donc theta(N/2).
\end{description}
\subsubsection{Implémentation à base d'arbres}


\subsection{Implémentation de la structure du labyrinthe}
Les données du labyrinthe sont stockées dans la structure Maze. \\
struct maze\_t \{ \\
\quad    UnionFind *union\_Find; \\
\quad     struct Walls *myWalls; \\
\quad     size\_t size; \\
\quad     size\_t number\_inner\_walls; \\
\};\\

La structure "maze\_t" contient la structure "UnionFind", qui sera décrite pour chaque implémentation par la suite. Elle contient également la structure "Walls" qui est un vecteur enregistrant tous les murs internes du labyrinthe. La variable "size" contient la taille du labyrinthe. La variable "number\_inner\_walls" contient le nombre de mur internes du labyrinthe. C'est également la taille du vecteur de type "Walls". \\
\linebreak
typedef struct Walls \{ \\
    Coord Cell1; \\
    Coord Cell2; \\
    bool wall\_between; \\
\};\\

La structure "Walls" contient les coordonnées de deux cellules adjacentes, partageant un mur. La variable booléenne "wall" vaut "true" si le mur est présent. Elle vaut "false" si le mur est absent.\\

\subsubsection{Implementation par listes chainées}
La structure union\_find\_t est décrite de cette manière : \\ \\
struct union\_find\_t \{ \\
    struct Element* elements; \\
    struct Sentinel* sentinels; \\
    size\_t numberComponents; \\
\}; \\ \\
Elle contient un vecteur "elements" contenant tous les élements du labyrinthe structurés en listes chainées. Elle contient également un vecteur "sentinels" contenant toutes les sentinelles pointant sur les premiers et derniers éléments de chaque liste chainée. La variable "numberComponents" contient le nombre d'ensembles distincts. \\ \\
typedef struct Element \{\\
    size\_t numero;\\
    struct Sentinel* head;\\
    struct Element* next;\\
\}Element;\\ \\
Le "numero" correspond à l'indice de l'élément dans le labyrinthe. Le pointeur "head" pointe vers la sentinelle de l'ensemble auquel appartient l'élément. Le pointeur "next" pointe vers l'élement suivant dans la liste chainée.\\
\\
typedef struct Sentinel \{ \\
    struct Element* first; \\
    struct Element* last; \\
    size\_t numberElements; \\
\}Sentinel;\\ \\
Le pointeur "first" pointe vers le premier élément de la liste chainée liée à la sentinelle. Le pointeur "last" pointe vers le dernier élément de cette liste. La variable "numberElements" contient le nombre d'éléments présents dans cette liste.
\subsubsection{Implementation par arbres}

 

\subsection{Pseudocode des fonctions mzCreate et MzIsValid}

\begin{codebox}
\Procname {$mzIsValid(maze)$}
\li    \If $\proc{ufComponentsCount}(maze->union\_Find) > 1$
\li    \Then \Return $false;$
\li    \Else 
\li 		\Return $true;$
\end{codebox}

\begin{codebox}
\Procname {$mzCreate(size)$}
	\li $innerWalls \gets \proc{NumberInnerWalls}(size)$
	\li $myMaze->size = size$
	\li $myMaze->union_find \gets \proc{ufCreate}(size * size)$
	\li $myMaze->number\_inner\_walls \gets innerWalls$
	\li $\proc{SetUpWalls}(myMaze->myWalls, size*size)$
	\li $\proc{ShuffleWalls}(myMaze->myWalls, myMaze->number\_inner\_walls)$	
	\li $wallsToTest \gets 0$	
	\li \While $!\proc{mzIsValid}(myMaze) \&\& wallsToTest < innerWalls$
	\li \Do $indexCell1 \gets \proc{IndexFromCoord}(myMaze->myWalls[wallsToTest].Cell1)$
	\li 	$indexCell2 \gets \proc{IndexFromCoord}(myMaze->myWalls[wallsToTest].Cell2)$
	\li 	$status \gets \proc{ufUnion}(myMaze->union\_Find, indexCell1, indexCell2)$
	\li 	\If $status == UF\_MERGED$
			\Then
	\li 		$close \gets \proc{mzIsWallClosed}(myMaze, myMaze->myWalls[wallsToTest].Cell1,$ \\$myMaze->myWalls[wallsToTest].Cell2)$
	\li 		$\proc{mzSetWall}(myMaze, myMaze->myWalls[wallsToTest].Cell1,$ \\ $ myMaze->myWalls[wallsToTest].Cell2, close)$
			\End
	\li $wallsToTest++$	
		\End
	\li \Return $myMaze$
\end{codebox}
\subsection{Analyse de la complexité en temps de mzCreate et mzIsValid}

\subsubsection{Implémentation à base de listes chainées}
\begin{description}
\item[mzIsValid :]La fonction ufComponentsCount s'écrit comme telle :
\begin{codebox}
\Procname{$ufComponentsCount(union_Find)$}
\li \Return $union_Find->numberComponents$
\end{codebox}
Dans tous les cas, sa complexité est theta(1).

\item[mzCreate :] Seules les parties de la fonction présentant une complexité égale ou supérieure à $N^{2}$ sont présentées. Les autres sont ignorées car négligeables. \textbf{Dans tous les cas.} La ligne 3 est theta($N^{2}$) car chaque cellule est visitée une à une. A la la ligne 5, ($N^{2}$) itérations sont nécessaires car toutes les cellules sont visitées. Donc theta($N^{2}$).
A la ligne 6, chaque mur intérieur est visité, ce qui fait 2$N^{2}$ - 2N opérations, donc theta($N^{2}$).
La boucle à la ligne 8 va varier en fonction du meilleur et du pire cas. \\
\textbf{Dans le meilleur cas}, chaque itération permet une connexion de cellules. Cela fait donc $N^{2}$-1 itérations nécessaires. Au sein de la boucle, toutes les instructions on une complexité linéaire. C'est également le cas pour la ligne 11 dans le meilleur des cas. Car à chaque connexion d'ensembles, seul un élément est connecté à la fois. Donc,\textbf{ dans le meilleur cas}, la complexité en temps est de l'ordre de Omega($N^{2}$).
\textbf{Dans le pire cas}, tous les éléments du vecteur myWalls sont visités. Cela fait donc 2$N^{2}$ - 2N  itérations. Il n'y aura cependant toujours que $N^{2}$-1 opérations de connexion de cellules. Donc seule la ligne 11 aura une complexité variable. L'analyse de la complexité du ufUnion va se faire pour les cas où N est une puissance de 2, par facilité. Le pire cas correspond à celui où les ensembles connectés sont toujours de taille égale. Au début, tous les ensembles seront de taille 1, puis de taille 2, 4, 8,... jusqu'à ce qu'il ne reste plus qu'un ensemble. En prenant le problème à l'envers, on part d'un ensemble de $N^{2}$ éléments à $N^{2}$ ensemble d'un éléments :
\begin{equation}
	T(1) = 0
	T(m^{2}) = \frac{N^{2}}{2} + T(\frac{m^{2}}{2} pour m = N
\end{equation}
Par Plug-and-Chug, on obtient la solution suivante :
\begin{equation}
	log_{2} (N^{2}) * \frac{N^{2}}{2}
\end{equation}
Le pire cas de la boucle qui démarre en ligne 8 influencera donc la complexité totale.
\textbf{Dans le pire cas}, la complexité est de l'ordre de Omega($log_{2}$ ($N^{2}$)*$N^{2}$)
On observe que la complexité en temps du pire et du meilleur cas sont très proches.
\end{description}


\subsubsection{Implémentation à base d'arbres}

\section{Analyse empirique}
\end{document}